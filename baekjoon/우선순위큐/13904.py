import sys, heapq

input = sys.stdin.readline

N = int(input().strip())
homework = []
que = []

for n in range(N):
    d, w = map(int, input().strip().split())
    homework.append((d, w))

homework.sort(key=lambda x: (-x[0], -x[1]))
print(homework)
day = homework[0][0]
score = 0
j = 0
for i in range(day, 0, -1):
    while True:
        if j >= len(homework) or homework[j][0] < i:
            break
        heapq.heappush(que, -homework[j][1])
        j += 1

    print(i, "일 차에 할 수 있는 과제", end="")
    print(que)

    if len(que) != 0:
        do = -heapq.heappop(que)
        score += do
        print("수행한 과제", do)
print(score)

# 마감일이 많이 남은 순 -> 점수가 높은 순(o)
'''
남은 과제 : [[6 5][4 60][4 40][4 10][3 30][2 50][1 20]]
날짜를 거꾸로 세야한다!! 그게 최선의 경우

6일차에 할 수 있는 과제 : [6 5]
수행(할 수 있는 과제 중 점수 가장 높은 것) : [6 5]
남은 과제 : [[4 60][4 40][4 10][3 30][2 50][1 20]]

5일차에 할 수 있는 과제 : x
수행(할 수 있는 과제 중 점수 가장 높은 것) : x
남은 과제 : [[4 60][4 40][4 10][3 30][2 50][1 20]]

4일차에 할 수 있는 과제 : [[4 60][4 40][4 10]]
수행(할 수 있는 과제 중 점수 가장 높은 것) : [4 60]
남은 과제 : [[4 40][4 10][3 30][2 50][1 20]]

3일차에 할 수 있는 과제 : [[4 40][4 10][3 30]]
수행(할 수 있는 과제 중 점수 가장 높은 것) : [4 40]
남은 과제 : [[4 10][3 30][2 50][1 20]]

2일차에 할 수 있는 과제 : [4 10][3 30][2 50]
수행(할 수 있는 과제 중 점수 가장 높은 것) : [2 50]
남은 과제 : [[4 10][3 30][1 20]]

1일차에 할 수 있는 과제 : [[4 10][3 30][1 20]]
수행(할 수 있는 과제 중 점수 가장 높은 것) : [3 30]
남은 과제 : [[4 10][1 20]]
'''
# 반례 모음
'''
<문제에서 주어진 입력>
7
4 60
4 40
1 20
2 50
3 30
4 10
6 5
답 : 185

<kwakws0627 님>
5
3 1
3 2
3 3
2 10
1 10
답 : 23

<rhdqor213 님>
3
1 1
1 2
1 3
답 : 3
'''
# 마감일이 가장 급한 순으로 정렬(x)
'''
[(1, 20), (2, 50), (3, 30), (4, 10), (4, 40), (4, 60), (6, 5)]
1일차에 (1,20) 수행
que 1
score 20

(2,50)는 2가 1보다 크므로 수행 가능
1빼고 2 추가
que 2
score 20+50

(3,30)은 3이 2보다 크므로 수행 가능 
2 빼고 3 추가
que 3
score 20+50+30

(4, 10)은 4는 3보다 크므로 수행 가능
3 지우고 4 추가
que 4
score 20+50+30+10

(4, 40)은 4는 4랑 같으므로 수행 불가능
큐 그대로
que 4
점수가 더 크니까 
score에서 10빼고 40 추가
score 20+50+30+10-10+40

(4, 60)은 4와 4가 같으므로 수행 불가능
큐 그대로
que 4
score에서 40빼고 60 추가
score 20+50+30+10-10+40-40+60

(6, 5)는 6이 4보다 크므로 수행 가능
4 지우고 6
que 6
score 20+50+30+10-10+40-40+60+5

어 185가 아니고 165네 오마이갓

1. que에 lecture의 가장 빠른 마감일의 과제 추가 / 점수 추가
2. lecture의 다음 과제를 수행할 수 있으면 큐 지우고 마감일 추가 / 점수 추가
3. lecture의 다음 과제를 수행할 수 없으면 큐 그대로 / 전에 추가된 점수랑 현 과제 점수랑 비교해서 더 큰 것 남기기
'''
# 점수가 큰 순으로 정렬해보면, 점수가 같으면 날짜가 빠른순으로 정렬(x)
'''
[[4, 60], [2, 60], [4, 40], [3, 30], [1, 20], [4, 10], [6, 5]]

4일차엔 60 고정  [(4,60)]
2일차엔 60 고정  [(4,60) (2,60)]
4일차엔 이미 고정되어있으니까 패스 [(4,60) (2,60) (4,40)] pop하면 뭐가 빠지나? (4, 40)이 빠져야해
0번째요소에 대해 오름차순, 1번째 요소에 대해 내림차순
즉, [(2,60)(4,60)(4, 40)] 
3일차엔 30 고정
1일차엔 20 고정
4일차엔 이미 고정되어있으니까 패스
6일차엔 5 고정

[[1, 3], [1, 2], [1, 1]]
1일차엔 3 고정
1일차엔 이미 고정되어있으니까 패스
1일차엔 이미 고정되어있으니까 패스



[4, 60]
첫날은 무조건 수행 가능
score = 60
day = 1

[2, 50]
day(1)가 2보다 작으니까 수행 가능
score = 60 + 50
day = 2

[4,40]
day(2)가 4보다 작으니까 수행 가능
score = 60 + 50 + 40
day = 3

[3,30]
day(3)가 3과 같으니까 수행 가능
score = 60 + 50 + 40 + 30
day = 4

[1, 20]
day(4)가 1보다 크니까 수행 불가능
score 그대로
day = 5

[4, 10]
day(5)가 4보다 크니까 수행 불가능
score 그대로
day = 6

[6, 5]
day(6)가 6과 같으니까 수행 가능
score = 60 + 50 + 40 + 30 + 5
day = 7
day == N 이므로 while문 탈출
score = 185!!

1. que에 lecture의 가장 점수가 높은 과제 먼저 추가
2. lecture의 다음 과제를 수행할 수 있으면 점수 추가
3. lecture의 다음 과제를 수행할 수 없으면 점수 그대로
'''

